import { createSlice, PayloadAction } from "@reduxjs/toolkit";
import { RootState } from "../store";

export enum ExecutionStatus {
  /** Represents when the VM has been loaded with code */
  STARTED,
  /** Represents when the VM has begun running on an interval */
  RUNNING,
  /** Represents when the VM has been stopped and the state has been cleared */
  STOPPED,
  /** Execution is paused but the state is saved and code is still loaded */
  PAUSED,
}

/**
 * Reducer responsible for the execution of the JS
 */
export const vmSlice = createSlice({
  name: "vm",
  initialState: {
    code: null as string | null,
    status: ExecutionStatus.STOPPED,
  },
  reducers: {
    startExecution(state) {
      if (state.code) {
        state.status = ExecutionStatus.STARTED;
      }

      return state;
    },
    run(state) {
      state.status = ExecutionStatus.RUNNING;

      return state;
    },
    pause(state) {
      state.status = ExecutionStatus.PAUSED;

      return state;
    },
    stopExecution(state) {
      state.status = ExecutionStatus.STOPPED;

      return state;
    },
    setCode(state, action: PayloadAction<{ code: string }>) {
      state.code = action.payload.code;
      return state;
    },
  },
});

export const getExecutionStatus = (state: RootState) => state.vm.status;

/**
 * Returns whether the interpreter has been started or not.
 *
 * @param state the root state of the application
 *
 * @returns true if the interpreter is started, false otherwise.
 */
export const isExecuting = (state: RootState) =>
  state.vm.status !== ExecutionStatus.STOPPED;

/**
 * Retrieves the current JS code generated by blockly.
 *
 * @param state the root state of the application
 *
 * @returns the code as a string
 */
export const getCode = (state: RootState) => state.vm.code;
